<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="

# 细节内容

## 困难性问题

困难性问题是指一类决策问题，这类问题不能在多项式时间内解决。">
<meta property="og:title" content="论文汇报01">
<meta property="og:description" content="

# 细节内容

## 困难性问题

困难性问题是指一类决策问题，这类问题不能在多项式时间内解决。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://Carolynhomes.github.io/Carolynhomes/post/lun-wen-hui-bao-01.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>论文汇报01</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}

</style>




<body>
    <div id="header">
<h1 class="postTitle">论文汇报01</h1>
<div class="title-right">
    <a href="https://Carolynhomes.github.io/Carolynhomes" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/Carolynhomes/Carolynhomes/issues/22" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>细节内容</h1>
<h2>困难性问题</h2>
<p>困难性问题是指一类决策问题，这类问题不能在多项式时间内解决。典型例子包括 <code class="notranslate">NP 完全问题 </code>，如旅行商问题和背包问题等。</p>
<h3>离散对数难题 DLP</h3>
<h4>定义：</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2559021c48b61acd706b94580ceaf59a33ab624d5325b701da004f55dd6d1bbe/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733303939303637353432362d39383138643063382d653137632d343261622d626235642d6437353830636134346139342e706e67"><img src="https://camo.githubusercontent.com/2559021c48b61acd706b94580ceaf59a33ab624d5325b701da004f55dd6d1bbe/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733303939303637353432362d39383138643063382d653137632d343261622d626235642d6437353830636134346139342e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1730990675426-9818d0c8-e17c-42ab-bb5d-d7580ca44a94.png" style="max-width: 100%;"></a></p>
<ul>
<li>群： 是代数中一个基础的数学结构，它由<strong>一个元素集合</strong>和一个<strong>二元运算（如加法或乘法）构成</strong>，并满足特定的性质。
<ul>
<li><code class="notranslate"> 群 G</code>  定义为一个集合及其上的运算 ∗*∗，并满足以下四个性质：</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8e33f9356dc36fddc41dd61d0944b3699ee262c44de12e080af0b0f6965faace/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733303939303835393837362d37386235393663632d396365342d346635342d616264362d3837346537306232383466332e706e67"><img src="https://camo.githubusercontent.com/8e33f9356dc36fddc41dd61d0944b3699ee262c44de12e080af0b0f6965faace/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733303939303835393837362d37386235393663632d396365342d346635342d616264362d3837346537306232383466332e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1730990859876-78b596cc-9ce4-4f54-abd6-874e70b284f3.png" style="max-width: 100%;"></a></p>
<ul>
<li>有限群： 是指一个元素数量有限的群 。
<ul>
<li><strong>整数模 p的乘法群</strong>：记作<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f7a878d72ac0f2d178ddb64fc9ffa66b1d69a8bd20af130e4eed609b3c2a33f2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f39323537363037383239363131323765363936643931316235363836373138332e737667"><img src="https://camo.githubusercontent.com/f7a878d72ac0f2d178ddb64fc9ffa66b1d69a8bd20af130e4eed609b3c2a33f2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f39323537363037383239363131323765363936643931316235363836373138332e737667" alt="image" data-canonical-src="https://cdn.nlark.com/yuque/__latex/925760782961127e696d911b56867183.svg" style="max-width: 100%;"></a>，<strong>它包含所有在模 p下的非零整数和乘法运算</strong>。这类群经常用于<strong>密码学</strong>，尤其是当 p 为素数时，它是一个<strong>封闭的群结构</strong>。</li>
<li>椭圆曲线群：在椭圆曲线上通过点加法形成的群，特别适合于椭圆曲线密码学（ECC）。</li>
</ul>
</li>
<li>在<strong>离散对数难题</strong>中，我们通常选择一个素数 p作为模数，并在有限域<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/03cfb8020bcb608ca10f1aab3f69d5bbd86afe254ebad2f706941f87ee550678/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f37316131626638383162396365663966306436633831636232393436333336322e737667"><img src="https://camo.githubusercontent.com/03cfb8020bcb608ca10f1aab3f69d5bbd86afe254ebad2f706941f87ee550678/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f37316131626638383162396365663966306436633831636232393436333336322e737667" alt="image" data-canonical-src="https://cdn.nlark.com/yuque/__latex/71a1bf881b9cef9f0d6c81cb29463362.svg" style="max-width: 100%;"></a> 上进行运算。</li>
<li></li>
<li>生成元： 群中一个特殊的元素，**通过反复对其进行群运算可以生成整个群的所有元素。  **
<ul>
<li>对于一个有限群 G中的生成元 g，如果我们不断将 g 自身相乘（或在加法群中自加），我们可以得到群内的<strong>每一个元素</strong>。数学上，如果对于群 G 中的任意元素 a，都存在整数 k 使得 <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5b02a72f6506c35028460a82d5be81464f5bd11e4bbf5b68155f3ae3fe55cbb3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f38373838666363643362386439316534653961383165343965393836653139662e737667"><img src="https://camo.githubusercontent.com/5b02a72f6506c35028460a82d5be81464f5bd11e4bbf5b68155f3ae3fe55cbb3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f38373838666363643362386439316534653961383165343965393836653139662e737667" alt="image" data-canonical-src="https://cdn.nlark.com/yuque/__latex/8788fccd3b8d91e4e9a81e49e986e19f.svg" style="max-width: 100%;"></a>，那么我们称 g是 G的生成元。</li>
</ul>
</li>
</ul>
<details><summary id="user-content-u2c147696"><span>生成元性质</span></summary><ul><li id="user-content-uaa8fe791"><span>如果群 G 是一个素数阶的有限群，则存在一个生成元。</span></li><li id="user-content-ufbbbdac5"><span>生成元 g 满足：对群中任意元素 a，都存在一个整数 k使 </span><span id="user-content-kzxpd"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5b02a72f6506c35028460a82d5be81464f5bd11e4bbf5b68155f3ae3fe55cbb3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f38373838666363643362386439316534653961383165343965393836653139662e737667"><img src="https://camo.githubusercontent.com/5b02a72f6506c35028460a82d5be81464f5bd11e4bbf5b68155f3ae3fe55cbb3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f5f5f6c617465782f38373838666363643362386439316534653961383165343965393836653139662e737667" data-canonical-src="https://cdn.nlark.com/yuque/__latex/8788fccd3b8d91e4e9a81e49e986e19f.svg" style="max-width: 100%;"></a></span><span>。</span></li><li id="user-content-u57c9d303"><span>生成元 gg 的幂次运算能“遍历”群中的所有元素，这种遍历顺序通常称为生成元 g 的“循环”。</span></li></ul></details>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/758427b3023247cc5f536a2b151ea7fbacdb7a76056d3dd7b194039485177a97/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363138373235302d39666433386335322d353331372d343939352d393034392d3066303336393232366535632e706e67"><img src="https://camo.githubusercontent.com/758427b3023247cc5f536a2b151ea7fbacdb7a76056d3dd7b194039485177a97/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363138373235302d39666433386335322d353331372d343939352d393034392d3066303336393232366535632e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1731026187250-9fd38c52-5317-4995-9049-0f0369226e5c.png" style="max-width: 100%;"></a></p>
<h4>生成元例子</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/60d57267ebfcb4572aa75094f3ef1205286c99ccd26e6d4bdf52ec8493a27eea/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363231343331302d35633930333262662d386632612d343665612d383531312d3038333439613133393135622e706e67"><img src="https://camo.githubusercontent.com/60d57267ebfcb4572aa75094f3ef1205286c99ccd26e6d4bdf52ec8493a27eea/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363231343331302d35633930333262662d386632612d343665612d383531312d3038333439613133393135622e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1731026214310-5c9032bf-8f2a-46ea-8511-08349a13915b.png" style="max-width: 100%;"></a></p>
<h3>DLP 及其衍生的难题的应用</h3>
<h4>Diffie-Hellman 密钥交换</h4>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4543e561f0f013280fe51875f1ccb003e4a7515b29693cde3e8b220c6d562697/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363332353837362d33663230303639622d323832352d346463362d386565622d6663396662663330646130342e706e67"><img src="https://camo.githubusercontent.com/4543e561f0f013280fe51875f1ccb003e4a7515b29693cde3e8b220c6d562697/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032363332353837362d33663230303639622d323832352d346463362d386565622d6663396662663330646130342e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1731026325876-3f20069b-2825-4dc6-8eeb-fc9fbf30da04.png" style="max-width: 100%;"></a></p>
<h4>数字签名依赖于离散对数问题</h4>
<blockquote>
<p>CDH （计算 Diffie-Hellman 难题）就是基于离散对数问题（DLP）衍生出来的</p>
</blockquote>
<p>在数字签名中，CDH 难题被用于生成签名密钥，以确保签名的真实性、完整性和不可抵赖性。</p>
<h4>密钥交换协议、伪随机数生成器</h4>
<p>CDH （计算 Diffie-Hellman 难题）就是基于离散对数问题（DLP）衍生出来的</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/36282eeb881e5c16edde033490e008342f48aaaf71df4932c8874176ff41e6dc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032373030333933352d62303162313631632d616638362d343166342d383935302d3562653738643663653864312e706e67"><img src="https://camo.githubusercontent.com/36282eeb881e5c16edde033490e008342f48aaaf71df4932c8874176ff41e6dc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f706e672f33353038313535382f313733313032373030333933352d62303162313631632d616638362d343166342d383935302d3562653738643663653864312e706e67" alt="" data-canonical-src="https://cdn.nlark.com/yuque/0/2024/png/35081558/1731027003935-b01b161c-af86-41f4-8950-5be78d6ce8d1.png" style="max-width: 100%;"></a></p>
<h2>数字签名</h2>
<p>数字签名一般用于验证数字信息的真实性、完整性和不可抵赖性  。 <strong>它的工作原理类似于手写签名或印章，但它使用公钥加密算法确保数字签名在电子通信中的安全性。数字签名被广泛应用于电子邮件、电子商务、软件分发</strong>等需要验证数据来源和完整性的场景。</p>
<h3>主要功能</h3>
<ul>
<li><strong>认证</strong>：验证信息发送者的身份，确保信息确实来自指定的发送者。</li>
<li><strong>完整性</strong>：确保信息在传输过程中未被篡改，任何对数据的修改都会导致签名验证失败。</li>
<li><strong>不可抵赖性</strong>：签名者无法否认自己发送的信息，因为只有签名者的私钥才能生成对应的数字签名。</li>
</ul>
<h3>基本工作原理</h3>
<p>数字签名通常使用<strong>公钥加密体系</strong>，包括<strong>私钥</strong>和<strong>公钥</strong>两部分。基本的数字签名过程如下：</p>
<ol>
<li><strong>生成消息摘要</strong>：发送方对原始消息使用哈希函数（如SHA-256）生成一个消息摘要。这一摘要是固定长度的且唯一地对应原始消息，任何对消息的改动都会导致不同的摘要值。</li>
<li><strong>使用私钥加密摘要</strong>：发送方<strong>使用自己的私钥对消息摘要进行加密</strong>，生成<strong>数字签名</strong>。这一步加密确保了只有拥有该私钥的人才能生成这一签名。</li>
<li><strong>发送消息和签名</strong>：发送方将原始消息和签名一同发送给接收方。</li>
<li><strong>验证签名</strong>：
<ul>
<li>接收方使用<strong>发送方的公钥</strong>对签名解密，得到原始的消息摘要。</li>
<li>接收方也对收到的消息内容<strong>重新计算一遍</strong>摘要。</li>
<li>如果解密得到的摘要与重新计算的摘要<strong>一致</strong>，则证明签名有效，消息完整且确实来自发送方。</li>
</ul>
</li>
</ol>
<h3>应用场景</h3>
<ul>
<li><strong>电子邮件和信息传递</strong>：数字签名在电子邮件中被用来<strong>确认发送方的身份并确保邮件内容未被篡改。</strong></li>
<li><strong>软件分发</strong>：软件发布者使用数字签名对<strong>软件</strong>进行<strong>签名</strong>，接收者可以<strong>验证签名</strong>来确认软件的真实性，确保没有恶意篡改。这在防止恶意软件和木马程序传播方面非常有效。</li>
<li><strong>区块链和加密货币</strong>：在区块链系统（如比特币、以太坊）中，交易通过数字签名来验证<strong>用户身份和交易真实性</strong>，确保每笔交易只能由合法的<strong>私钥持有者</strong>发起。</li>
<li><strong>电子合同和数字文档</strong>：数字签名在电子合同中确<strong>保签名人的身份</strong>，任何对合同内容的更改都会导致签名无效，使得数字签名在电子合同管理中至关重要。</li>
</ul>
<h2>同态加密</h2>
<h3>同态加密体系</h3>
<p>同态加密体系是一种特殊的加密技术，它<code class="notranslate">允许在加密数据上进行某些计算</code>，得到的结果在解密后与直接在明文上进行的相同计算结果一致。<br>
这种加密方法的关键优势在于它可以保护数据的隐私性，同时允许授权的第三方<code class="notranslate">对加密数据进行处理和分析</code>，而无需了解数据的实际内容。</p>
<h4>基本步骤</h4>
<ul>
<li>密钥生成（Key Generation）：生成一对密钥，包括公钥和私钥。公钥用于加密数据，私钥用于解密数据和执行同态计算。</li>
<li>加密（Encryption）：使用公钥将明文数据转换为加密数据（密文）。</li>
<li>同态计算（Homomorphic Computation）：在加密数据上执行特定的计算，这些计算可以在解密后进行还原，得到与明文计算相同的结果。</li>
<li>解密（Decryption）：使用私钥将加密计算的结果转换回明文。</li>
</ul>
<h4>等级</h4>
<p>态加密可以分为不同的等级，根据其支持的运算类型和次数，可以分为<code class="notranslate">部分同态加密</code>（Partially Homomorphic Encryption, PHE）、<code class="notranslate">有些同态加密</code>（Somewhat Homomorphic Encryption, SWHE）和<code class="notranslate">全同态加密</code>（Fully Homomorphic Encryption, FHE）。其中，<strong>全同态加密允许在加密数据上进行任意次数的加法和乘法运算，并且在每次运算后都能维持加密状态.</strong></p>
<p><a target="_blank" rel="noopener noreferrer" href="./res/20241106164901.png"><img src="./res/20241106164901.png" alt="" style="max-width: 100%;"></a></p>
<h2>区块链</h2>
<p>区块链是一种去中心化的、不可篡改的分布式账本技术， 其核心特点在于<strong>数据的不可篡改性</strong>和<strong>数据的透明性</strong>。</p>
<ul>
<li>区块链通过加密、共识机制和链式结构来记录交易和数据，使数据在全网范围内可信。</li>
</ul>
<blockquote>
<p>区块链被称为分布式账本技术，主要是因为它的<strong>数据存储和验证机制</strong>，实现了**数据的分散存储、共享和管理  **</p>
</blockquote>
<details><summary id="user-content-u6118bca8"><span>主要特点</span></summary><ul><li id="user-content-ue4fa88c6"><strong><span>去中心化</span></strong><span>：区块链网络中的每个节点都拥有同样的账本记录，</span><strong><span>没有单一的控制中心</span></strong><span>，从而避免了单点失效的问题。</span></li><li id="user-content-ub1e98ed3"><strong><span>不可篡改性</span></strong><span>：每个区块都包含</span><strong><span>前一个区块的哈希值</span></strong><span>，这种链式结构保证了数据的不可更改，一旦记录，就无法在不被检测的情况下篡改。</span></li><li id="user-content-u87980cb4"><strong><span>透明性和可追溯性</span></strong><span>：区块链上的每一笔交易都</span><strong><span>是公开的</span></strong><span>，</span><strong><span>所有</span></strong><span>节点可以查看</span><strong><span>每笔</span></strong><span>交易，从而保证了数据的公开透明和可追溯性。</span></li></ul></details>
<p>:::color4<br>
在本论文的方案中，区块链的去中心化和透明性提供了一个可靠的基础，使数据审计过程公开且无法被篡改，这为云存储的数据完整性审计提供了信任保障。</p>
<p>:::</p>
<h2>以太坊</h2>
<p>以太坊是一个基于区块链的去<strong>中心化平台</strong>，支持智能合约的执行。</p>
<ul>
<li>与比特币的设计不同，<strong>以太坊不仅用于转移数字货币，还允许开发和运行去中心化应用（DApps）</strong>，使其成为目前广泛使用的<strong>智能合约平台</strong>。</li>
</ul>
<details><summary id="user-content-u54cd5df1"><span>以太坊核心</span></summary><p id="user-content-ua88d9783"><strong><span>以太坊虚拟机（EVM）</span></strong><span>：EVM是以太坊的核心组件，它可以在</span><strong><span>去中心化网络上运行代码</span></strong><span>。开发者可以通过</span><strong><span>编写</span></strong><span>智能合约部署在EVM上，使合约能够在去中心化的环境中自动执行。  </span></p><p id="user-content-ue25568fc"><span>通过使用以太坊虚拟机，</span><strong><span>智能合约将被编译成字节码形式</span></strong><span>，然后在以太坊网络上执行。</span></p></details>
<p><strong>广泛的应用场景</strong>：<strong>以太坊的智能合约平台</strong>支持金融、供应链管理、身份验证、数据管理等多种应用。</p>
<p>任何需要安全、透明的业务流程都可以通过以太坊实现<strong>自动化管理</strong>。</p>
<details><summary id="user-content-u3762b6d0"><span>以太坊具体是怎么在各个场景应用的</span></summary><h3 id="user-content-swxqw"><strong><span>智能合约和去中心化应用（DApps）</span></strong></h3><p id="user-content-uad00ad9f"><span>以太坊允许开发者在其平台上构建和运行去中心化应用（DApps）。DApps不依赖于中心服务器，而是通过分布式网络的节点来运行。常见应用场景包括：</span></p><ul><li id="user-content-u3d9cd15f"><strong><span>数字身份管理</span></strong><span>：用户可以通过DApps来管理和验证自己的数字身份，不需要依赖政府或公司，适合各种需要验证身份的场景，如在线投票、证书认证等。</span></li><li id="user-content-u3bf31099"><strong><span>去中心化社交媒体</span></strong><span>：去中心化社交媒体平台（如Minds）可以在没有中心服务器的情况下运行，数据内容由用户控制，减少内容审查和数据泄露的风险。</span></li><li id="user-content-u0928ba4f"><strong><span>内容创作者奖励平台</span></strong><span>：创作者可以通过智能合约直接获得粉丝的打赏或内容使用费用，去除中介费用，保障收益。</span></li></ul><h3 id="user-content-y3aot"><span></span><strong><span>去中心化自治组织（DAO）</span></strong></h3><p id="user-content-u00299d0f"><span>DAO是一种没有中心化领导的组织形式，通过智能合约规则自动化管理。DAO的成员可以通过投票等方式共同决策，实现分散化的管理。以太坊是DAO发展的重要平台，典型应用包括：</span></p><ul><li id="user-content-u337ddbfc"><strong><span>集体投资</span></strong><span>：DAO可以用于集体投资项目，成员通过投票决定如何使用资金，共享收益。</span></li><li id="user-content-u1f27ce56"><strong><span>社区自治</span></strong><span>：DAO适用于社区治理，成员可以对社区项目的决策、资源分配等事项进行投票。</span></li><li id="user-content-u445720e7"><strong><span>去中心化基金</span></strong><span>：DAO形式的基金允许投资者直接参与项目管理和决策，增加了参与者的透明度和参与度。</span></li></ul><p id="user-content-ud6d11649"><br></p></details>
<h2>智能合约</h2>
<p><strong>智能合约是自动执行的程序，它将传统合约的条款和条件</strong>以<strong>代码</strong>形式编写，并<strong>部署在区块链</strong>上。<strong>实现了全球范围内的即时交易和自动化清算。</strong></p>
<p>智能合约的**最大特点<strong>是</strong>自动执行和无需第三方信任**。一旦部署在区块链上，智能合约的内容和执行逻辑将无法更改，任何人都无法随意更改其内容。</p>
<ul>
<li>智能合约可以通过一些开发工具进行编写，比如 <code class="notranslate">Solidity</code> 和 <code class="notranslate">Vyper</code> 等</li>
</ul>
<details><summary id="user-content-ud4089919"><span>自动执行和无需第三方信任</span></summary><ul><li id="user-content-u26d0024a"><strong><span>可编程性和自动执行</span></strong><span>：智能合约可以根据事先设定的条件自动执行操作。例如，</span><strong><span>若满足某些条件，智能合约会自动完成任务，无需人工干预。</span></strong></li><li id="user-content-uedc24894"><strong><span>无需第三方信任</span></strong><span>：智能合约的执行完全依赖于代码本身，</span><strong><span>不需要中间人</span></strong><span>，这保证了交易和流程的透明性和安全性。</span></li></ul></details>
<p>:::color4<br>
在论文中，智能合约用于实现审计过程的自动化和透明化。</p>
<p><strong>例如</strong>，当多个审计者共同生成数据完整性挑战时，智能合约会根据设定的规则自动触发审计任务，管理和验证审计结果，并将结果公开在区块链上。</p>
<p>通过智能合约，整个审计流程可以实时监控，所有参与者都能查看审计的细节。</p>
<p>:::</p>
<h2>哈希函数</h2>
<p>哈希函数将<strong>任意长度的数据</strong>映射成一个<strong>固定长度的比特串。是一个单向函数</strong>，即根据哈希值计算其原始输入在计算上是不可行的。</p>
<h3>理想哈希函数的特性</h3>
<ul>
<li>**抗原像性：**给定一个哈希值 h，应该很难找到任何消息 m，使得 h = hash(m)。这个概念与单向函数的概念有关。缺乏这一特性的函数容易受到原像攻击。</li>
</ul>
<blockquote>
<p><strong>原像攻击</strong>（Preimage Attack）是一种试图找到原始输入数据的攻击方法。其目标是通过已知的哈希值（散列值）去推导或找到对应的原始数据。</p>
</blockquote>
<ul>
<li>**抗第二原像性：**给定一个输入 m1，应该很难找到一个不同的输入 m2，使得 hash(m1) =hash(m2)。这一属性有时被称为抗弱碰撞性。缺乏这一特性的函数容易受到第二原像攻击。</li>
<li>**抗碰撞性：**应该很难找到两个不同的信息 m1和 m2，使得 hash(m1) = hash(m2)。这样的一个对被称为密码学哈希碰撞。这一特性有时被称为抗强碰撞性。它要求哈希值的长度至少是抗原像性要求的两倍；否则，碰撞可能被生日攻击发现。</li>
</ul>
<h3>原像攻击</h3>
<p><strong>原像攻击</strong>（Preimage Attack）是一种试图找到原始输入数据的攻击方法。其目标是通过已知的哈希值（散列值）去推导或找到对应的原始数据。</p>
<p>原像攻击分为两种情况：</p>
<ol>
<li><strong>第一原像攻击（First Preimage Attack）</strong>：
<ul>
<li>给定一个哈希值 h，攻击者尝试找到某个输入 x 使得 H(x)=h，其中 H 是哈希函数。</li>
<li><strong>这种攻击难度取决于哈希函数的结构和输出长度。</strong></li>
<li>理想情况下，一个哈希函数的抗第一原像性<strong>意味着攻击者在计算上无法找到这样的 x</strong>，即便有非常强的计算资源。</li>
</ul>
</li>
<li><strong>第二原像攻击（Second Preimage Attack）</strong>：
<ul>
<li>给定一个特定的输入 x1 和其对应的哈希值 H(x1)=h，攻击者尝试找到另一个不同的输入 x2, 使得 H(x2)=H(x1)。</li>
<li>第二原像攻击的<strong>难度通常小于</strong>第一原像攻击，但依然非常困难。如果哈希函数具有良好的抗第二原像性，则攻击者无<strong>法轻易找到</strong>一个与给定输入有相同哈希值的<strong>其他输入</strong>。</li>
</ul>
</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://Carolynhomes.github.io/Carolynhomes">牧天白衣</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","Carolynhomes/Carolynhomes");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}



</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/articletoc.js'></script>

</html>
