<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>牧天白衣</title><link>https://Carolynhomes.github.io/Carolynhomes</link><description>哎，今天又是美好的一天哟！！！！！</description><copyright>牧天白衣</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://Carolynhomes.github.io/Carolynhomes</link></image><lastBuildDate>Thu, 28 Nov 2024 09:20:13 +0000</lastBuildDate><managingEditor>牧天白衣</managingEditor><ttl>60</ttl><webMaster>牧天白衣</webMaster><item><title>信息安全基础02</title><link>https://Carolynhomes.github.io/Carolynhomes/post/xin-xi-an-quan-ji-chu-02.html</link><description># 第二章 密码学基础&#13;
&#13;
## 1. 密码分析分类&#13;
&#13;
&gt; 密文： `Ciphertext`	明文：`Plaintext`&#13;
&#13;
唯密文攻击&#13;
&#13;
- 破译者已知：加密算法、待破译的密文&#13;
- `是最困难的`&#13;
&#13;
已知明文攻击&#13;
&#13;
- 破译者已知：加密算法、一定数量的密文和对应的明文&#13;
&#13;
选择明文攻击&#13;
&#13;
- 破译者已知：加密算法、选定的明文和对应的密文&#13;
&#13;
选择密文攻击&#13;
&#13;
- 破译者已知：加密算法、选定的密文和对应的明文&#13;
&#13;
选择文本攻击&#13;
&#13;
- 破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文&#13;
&#13;
&gt; 一个密码体制是安全的，通常是指在前三种攻击下的安全性&#13;
&#13;
## 2. 密码系统的安全条件&#13;
&#13;
密码系统的安全性`只寓于密钥`，通常假定算法是公开的&#13;
&#13;
## 3. 破译算法分级&#13;
&#13;
全部破译&#13;
&#13;
全部推导&#13;
&#13;
实例推导&#13;
&#13;
信息推导&#13;
&#13;
## 4. 衡量攻击方法的复杂性&#13;
&#13;
数据复杂性&#13;
&#13;
处理复杂性&#13;
&#13;
存储需求&#13;
&#13;
## 5. 评价密码体制安全性的三个途径&#13;
&#13;
计算安全性&#13;
&#13;
可证明安全性&#13;
&#13;
无条件安全性&#13;
&#13;
## 6. 一个密码系统实际安全的条件&#13;
&#13;
- 每一个加密函数和每一个解密函数都能有效的计算&#13;
- 破译者取得密文后将**不能在有效的时间**或**成本范围内**破解出密钥或明文&#13;
- `一个密码系统是安全的必要条件`：**穷举密钥搜索**将是不可行的&#13;
&#13;
## 7. 加密系统的几个知识点&#13;
&#13;
用于将明文转换为密文的操作类型 &#13;
&#13;
- 替换  &#13;
- 置换&#13;
&#13;
使用的密钥数量&#13;
&#13;
- 对称密钥（单一密钥、秘密密钥或传统加密）  &#13;
- 非对称密钥（双密钥、公钥加密）&#13;
&#13;
明文处理的方式  &#13;
&#13;
- 块加密  &#13;
- 流加密&#13;
&#13;
## 8. 安全模型&#13;
&#13;
网络传输中的信息安全&#13;
&#13;
- 动态数据的安全&#13;
- 网络安全模型&#13;
&#13;
计算机系统中的信息安全&#13;
&#13;
- 静态数据的安全&#13;
- 网络访问安全模型&#13;
&#13;
![网络通信安全模型](http://cdn.jsdelivr.net/gh/Carolynhomes/images@main/img/Python/202411281531134.png)&#13;
&#13;
![网络访问安全模型](http://cdn.jsdelivr.net/gh/Carolynhomes/images@main/img/Python/202411281531564.png)&#13;
&#13;
## 9. 密码体制&#13;
&#13;
### 对称密码体制&#13;
&#13;
**优缺点:**&#13;
&#13;
**优点：**  加/解密处理速度快、保密度高等。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/xin-xi-an-quan-ji-chu-02.html</guid><pubDate>Thu, 28 Nov 2024 09:15:39 +0000</pubDate></item><item><title>进制转换</title><link>https://Carolynhomes.github.io/Carolynhomes/post/jin-zhi-zhuan-huan.html</link><description># 1. 任意进制转十进制&#13;
&#13;
```python&#13;
int_to_char = '0123456789ABCDEF'&#13;
char_to_int = {}&#13;
for idx, char in enumerate(int_to_char):&#13;
    char_to_int[char] = idx&#13;
&#13;
# k进制数字x转换成十进制：0-9、A-F&#13;
def k_to_ten(k, x):&#13;
    ans = 0&#13;
    for char in x:&#13;
        ans = ans * k + char_to_int[char]&#13;
    return ans&#13;
&#13;
res = k_to_ten(2, '10001')&#13;
print(res)&#13;
```&#13;
&#13;
# 2. 十进制转任意进制&#13;
&#13;
除K取余法：十进制数字不断除以K求余数，然后逆序输出&#13;
&#13;
```python&#13;
int_to_char = '0123456789ABCDEF'&#13;
&#13;
# 十进制x转为k进制&#13;
def ten_to_k(k, x):&#13;
    ans = ''&#13;
    while x != 0:&#13;
        ans += int_to_char[x % k]&#13;
        x //= k&#13;
    &#13;
    return ans[::-1]&#13;
&#13;
print(ten_to_k(16, 31))&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/jin-zhi-zhuan-huan.html</guid><pubDate>Tue, 26 Nov 2024 13:50:18 +0000</pubDate></item><item><title>代码粘贴</title><link>https://Carolynhomes.github.io/Carolynhomes/post/dai-ma-zhan-tie.html</link><description>没挂梯子的时候：https://www.codepaste.cn/#/&#13;
挂梯子的时候：https://paste.org.cn/&#13;
&gt; [!tip]&#13;
&gt; 下面这个证书过期了，可能会报不安全，无碍~&#13;
。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/dai-ma-zhan-tie.html</guid><pubDate>Tue, 26 Nov 2024 06:47:44 +0000</pubDate></item><item><title>双指针</title><link>https://Carolynhomes.github.io/Carolynhomes/post/shuang-zhi-zhen.html</link><description>双指针：在区间操作时，利用两个下标同时遍历，进行高效操作&#13;
&#13;
`双指针利用性质可以把O(n²)时间降低到O(n)`&#13;
&#13;
## 反向扫描&#13;
&#13;
**两个指针，反向遍历**&#13;
&#13;
一般用于**有序数组** 或者 **字符串类**的问题&#13;
&#13;
### 例题&#13;
&#13;
- 回文字符串 蓝桥1371&#13;
&#13;
```python&#13;
s = input()&#13;
l, r = 0, len(s) - 1&#13;
flag = 'Y'&#13;
while l &lt;= r:&#13;
    if s[l] == s[r]:&#13;
        l += 1&#13;
        r -= 1&#13;
    else:&#13;
        flag = 'N'&#13;
        break&#13;
&#13;
print(flag) &#13;
```&#13;
&#13;
```python&#13;
s = input()&#13;
if s == s[::-1]:&#13;
    print('Y')&#13;
else:&#13;
    print('N')&#13;
```&#13;
&#13;
## 同向扫描--滑动窗口&#13;
&#13;
始终维护一个【left，right】的区间&#13;
&#13;
维护`[left,right]`区间中的信息：**区间和、各个元素个数等**&#13;
&#13;
- 左端点往右移动表示`删除元素`&#13;
&#13;
- 右端点往右移动表示`增加元素`&#13;
&#13;
当移动到尾部则停止，或满足特殊条件时停止&#13;
&#13;
### 例题&#13;
&#13;
- 蓝桥 1372&#13;
&#13;
```python&#13;
n, S = map(int, input().split())&#13;
a = list(map(int, input().split()))&#13;
# 找最小区间，满足区间之和 &gt;=S&#13;
min_len = n + 1&#13;
# [left, right)&#13;
left, right = 0, 0&#13;
&#13;
# tot表示滑动窗口[left, right)之间的区间和&#13;
tot = 0&#13;
while left &lt; n:&#13;
    # 不断扩展右端点，直至区间之和 &gt;= S&#13;
    while right &lt; n and tot &lt; S:&#13;
        tot += a[right]&#13;
        right += 1&#13;
    &#13;
    if tot &gt;= S:&#13;
        min_len = min(min_len, right - left) &#13;
    &#13;
    # 左端点往右走一步&#13;
    tot -= a[left]&#13;
    left += 1&#13;
&#13;
if min_len == n + 1:&#13;
    min_len = 0&#13;
&#13;
print(min_len)&#13;
```&#13;
&#13;
- 蓝桥 1621&#13;
&#13;
```python&#13;
n, m, k = map(int, input().split())&#13;
a = list(map(int, input().split()))&#13;
&#13;
# 找有多少个区间满足：至少k个数字大于等于m&#13;
ans = 0&#13;
&#13;
# [left, right)&#13;
left, right = 0, 0&#13;
&#13;
# cnt 表示滑动窗口[left, right)中大于等于m的元素个数&#13;
cnt = 0&#13;
while left &lt; n:&#13;
    # 不断扩展右端点，直至区间恰好有k个元素大于等于m&#13;
    while right &lt; n and cnt &lt; k:&#13;
        if a[right] &gt;= m:&#13;
            cnt += 1&#13;
        right += 1&#13;
    &#13;
    if cnt &gt;= k:&#13;
        # [left, righ-1]&#13;
        #...&#13;
        # [left, n-1]&#13;
        # n-1-(right-1)+1 = n - right + 1&#13;
        ans += n - right + 1&#13;
    &#13;
    # 左端点往右走一步&#13;
    if a[left] &gt;= m:&#13;
        cnt -= 1&#13;
    left += 1&#13;
&#13;
print(ans)&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/shuang-zhi-zhen.html</guid><pubDate>Mon, 25 Nov 2024 12:58:34 +0000</pubDate></item><item><title>贪心</title><link>https://Carolynhomes.github.io/Carolynhomes/post/tan-xin.html</link><description>## 贪心概念&#13;
&#13;
贪心：把整体问题分解成多个步骤，在每个步骤都选取当前步骤的最优方案，直到所有步骤结束，每个步骤不会影响后续步骤&#13;
&#13;
核心性质：每次采用局部最优，最终结果就全局最优&#13;
&#13;
&gt; 例子&#13;
&gt;&#13;
&gt; 最少硬币支付问题：1元、2元、5元，数量不限，现在需要支付M元，要求硬币数目最少，应该如何支付?&#13;
&gt;&#13;
&gt; 局部最优：要保证硬币尽可能少，所以当前尽可能选择大面值的硬币&#13;
&#13;
- 并不是所有采用局部最优都可以得到全局最优&#13;
&#13;
## 如何判断是否能用贪心&#13;
&#13;
- 最优子结构性质：当**一个问题的最优解包含子问题的最优解**，则称之为具有最优子结构性质&#13;
&#13;
具体问题怎么做：&#13;
&#13;
- 经验性积累各种类型的贪心&#13;
- 举反例&#13;
&#13;
## 经典贪心&#13;
&#13;
- 蓝桥545&#13;
&#13;
```python&#13;
# 只写了一个半成品&#13;
# 10分钟&#13;
```&#13;
&#13;
答案：&#13;
&#13;
```python&#13;
import heapq  # 堆&#13;
&#13;
n = int(input())&#13;
a = list(map(int, input().split()))&#13;
&#13;
heapq.heapify(a)  # # 将无序的list转为最小堆&#13;
ans = 0&#13;
&#13;
while len(a) != 1:&#13;
    x = heapq.heappop(a)  # 弹出并返回最小元素&#13;
    y = heapq.heappop(a)&#13;
    heapq.heappush(a, x + y)  # 向堆中添加元素&#13;
    ans += x + y&#13;
&#13;
print(ans)&#13;
```&#13;
&#13;
- 蓝桥杯532——分箱问题&#13;
&#13;
```python&#13;
# 每组纪念品价格上限&#13;
w = int(input())&#13;
&#13;
# n个纪念品&#13;
n = int(input())&#13;
&#13;
# n个纪念品的价格&#13;
a = []&#13;
for i in range(n):&#13;
    a.append(int(input()))&#13;
&#13;
# 1. 排序&#13;
a.sort()&#13;
# 最小的和最大的下标&#13;
l, r = 0, n - 1&#13;
ans = 0&#13;
&#13;
while True:&#13;
    if l == r:&#13;
        ans += 1&#13;
        break&#13;
&#13;
    if l &gt; r:&#13;
        break&#13;
&#13;
    # 能够配对&#13;
    if a[l] + a[r] &lt;= w:&#13;
        ans += 1&#13;
        l += 1&#13;
        r -= 1&#13;
    else:&#13;
        # 大的单独放&#13;
        ans += 1&#13;
        r -= 1&#13;
&#13;
print(ans)&#13;
```&#13;
&#13;
- 蓝桥杯209&#13;
&#13;
```python&#13;
s = list(input())&#13;
t = list(input())&#13;
n = len(s)&#13;
ans = 0&#13;
&#13;
# 逐一比对，只要能翻就翻&#13;
for i in range(n):&#13;
    if s[i] == t[i]:&#13;
        continue&#13;
&#13;
    if s[i + 1] == '*':&#13;
        s[i + 1] = 'o'&#13;
    else:&#13;
        s[i + 1] = '*'&#13;
    &#13;
    ans += 1&#13;
&#13;
print(ans)&#13;
```&#13;
&#13;
## 数组乘积问题&#13;
&#13;
![image-20241125200912044](http://cdn.jsdelivr.net/gh/Carolynhomes/images@main/img/Python/202411252009383.png)&#13;
&#13;
。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/tan-xin.html</guid><pubDate>Mon, 25 Nov 2024 12:10:25 +0000</pubDate></item><item><title>看剧看剧</title><link>https://Carolynhomes.github.io/Carolynhomes/post/kan-ju-kan-ju.html</link><description>奈飞工厂：https://www.netflixgc.com&#13;
&#13;
七味网：https://www.qwnull.com。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/kan-ju-kan-ju.html</guid><pubDate>Mon, 25 Nov 2024 11:35:48 +0000</pubDate></item><item><title>Gpt通知</title><link>https://Carolynhomes.github.io/Carolynhomes/post/Gpt-tong-zhi.html</link><description># 2024年11月27日13点41分&#13;
啥情况，都开始摸鱼了，不用了是吧 笑死哈哈哈哈哈哈&#13;
用不了的滴我就行~&#13;
&#13;
# 2024年11月24日20点12分&#13;
如果出现问题，需要回到首页，选择一个其他的房间&#13;
&#13;
&#13;
# 2024年11月23日19点26分&#13;
1. 更新到今天官网更新的UI&#13;
2. 已支持官网原生高级语音模式&#13;
&#13;
# 2024年11月20日11点49分&#13;
界面进行了改版，帐号是之前那个码，密码：1-6&#13;
而且可以自己注册，续费等等，链接贴一下：https://nbai.site/list/#/register?inviter=S85SL3&#13;
&#13;
现在官网的链接是下面图片这样，我现在的套餐还能3个月，之后就可能换成这些套餐了。</description><guid isPermaLink="true">https://Carolynhomes.github.io/Carolynhomes/post/Gpt-tong-zhi.html</guid><pubDate>Sun, 03 Nov 2024 09:37:37 +0000</pubDate></item></channel></rss>