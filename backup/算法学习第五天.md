# 1. 类

## 类和对象

```python
class student:
    # 属性
    x = "hello"

    # 初始化方法，初始化一个对象
    def __init__(self, name, class_idx):
        # 属性
        self.name = name
        self.class_idx = class_idx


A = student("张三", "一班")
B = student("李四", "二班")
print(A.name, A.class_idx)
print(B.name, B.class_idx)
```

- `__init__(self)`：构造方法
  
  - 可以包含多个参数，但是必须包含`self`参数
    
  - 且`self`必须为第一个参数，不需要手动传递参数
    
- 类的实例化：
  
  - 类名（参数），这里放的参数会传入`__init__`构造函数中
    
- 类中访问当前对象的属性和方法：通过`self`
  
- 对象访问属性和方法：通过`.`运算符
  

## 属性和方法

```python
class student:
    # 类的属性
    sex_list = ["boy", "girl"]

    # 初始化方法
    def __init__(self, name, sex, class_idx):
        # 属性
        self.name = name
        self.sex = sex
        self.class_idx = class_idx
    
    def get_sex(self):
        return self.sex_list[self.sex]

# 打印类属性
print(student.sex_list)

# 定义一个对象
a = student("Alice", 1, 5)
# 实例属性
print("姓名：", a.name)
# 实例方法
print("性别", a.get_sex())
# 实例属性
print("班级：", a.class_idx)

# 新增一个属性
a.score = 100
print("分数: ", a.score)       
```

实例方法：通常情况下，在类中定义的方法默认都是实例方法

- `实例名.方法名`、`self.方法名`
  

类方法：与实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为`cls`

- 类方法需要使用`@classmethod`修饰符进行修饰
  
- `类名.方法名`
  

类静态方法：没有类似self、cls这样的特殊参数，无法调用任何类属性和类方法。

- 使用`@staticmethod`修饰
  
- `类名.方法名`
  

```python
class student:
    # 类的属性
    sex_list = ["boy", "girl"]

    # 类方法
    @classmethod
    def get_sex_list(cls):
        # cls相对应的是整个class，self对应的是某个对象
        return cls.sex_list
    
    @staticmethod
    def test():
        print("hello world")

    # 初始化方法
    def __init__(self, name, sex, class_idx):
        # 属性
        self.name = name
        self.sex = sex
        self.class_idx = class_idx
    
    def get_sex(self):
        return self.sex_list[self.sex]


print(student.get_sex_list())
student.test()
```

# 2. 常用内置函数

| 数学操作函数 | 描述  |
| --- | --- |
| abs | 绝对值函数 |
| round | 四舍五入函数 |
| sum | 求和  |
| max | 最大值 |
| min | 最小值 |
| pow | 幂次  |
| complex | 构建虚数 |
| divmod | 返回商和余数 |
| eval | 执行字符串表达式，返回表达式的值 |
| hex | 转成16进制 |
| oct | 转成8进制 |
| bin | 转成2进制 |

| 函数  | 描述  |
| --- | --- |
| len | 求长度函数 |
| sorted | 排序函数 |
| zip | 打包成元组 |
| enumerate | 枚举  |
| range | 生成数字序列 |
| reversed | 翻转  |

| 函数  | 描述  |
| --- | --- |
| int | 整数  |
| dict | 字典  |
| tuple | 元组  |
| float | 浮点数 |
| type | 返回对象类型 |
| bool | 布尔  |
| id  | 返回对象唯一标识符 |
| str | 字符串 |
| chr | 整数转字符 |
| list | 列表  |
| set | 集合  |
| ord | 字符转整数 |

| 函数  | 描述  |
| --- | --- |
| help | 查看函数或模块用途的详细说明 |
| input | 输入  |
| all | 判断可迭代对象是否全为True |
| print | 输出  |
| any | 判断可迭代对象是否有一个为True |
| iter | 生成迭代器 |
| dir | 获取当前范围内的属性列表 |
| next | 迭代器下一个 |
| hasattr | 判断对象是否存在属性 |
| map | 序列做映射 |
| getattr | 返回对象的属性值 |

# 3. 自定义排序

`sorted(iterable, key=None, reverse=False)`：返回一个排序后的结果

- reverse = True 降序
  
- iterable：可迭代对象
  

```python
a = [1, 3, 2, 5, 4]
sorted_a = sorted(a)

# 升序
print("a = ", a)
print("sorted_a = ", sorted_a)

# 降序
sorted_a = sorted(a, reverse=True)
print("a = ", a)
print("sorted_a = ", sorted_a)
```

自定义规则：

- 写一个比较函数`cmp`
  
- 套入`functools`模块中的`cmp_to_key`
  

```python
from functools import cmp_to_key

# 自定义规则：当a<b返回负数，当a>b返回正数、两者相等返回0
# 自定义规则：当a排在前面返回负数，当b排前面，返回正数、二者相等返回0
def cmp(a, b):
    # 按照绝对值从小到大
    if abs(a) < abs(b):
        return -1
    elif abs(a) > abs(b):
        return 1
    else:
        return 0

a = [-2, 1, -3, -5, 4]
sorted_a = sorted(a)
print("普通排序从小到大：", sorted_a)

sorted_a = sorted(a, key=cmp_to_key(cmp))
print("按绝对值从小到大：", sorted_a)
```

```python
from functools import cmp_to_key


def cmp(a, b):
    if sum(a) < sum(b):
        return -1
    elif sum(a) > sum(b):
        return 1
    else: 
        if a[0] < b[0]:
            return -1
        elif a[0] > b[0]:
            return 1
        else:
            return 0

a = [(2, 3), (5, -2), (4, 5), (5, 0), (4, 1)]
sorted_a = sorted(a, key=cmp_to_key(cmp))
print("自定义排序: ", sorted_a)
# 自定义排序:  [(5, -2), (2, 3), (4, 1), (5, 0), (4, 5)]
```

```python
from functools import cmp_to_key


def cmp(a, b):
    if len(a) < len(b):
        return -1
    elif len(a) > len(b):
        return 1
    else:
        if a <= b:
            return -1
        else:
            return 0

a = ["Python", "Swift", "Java", "C++", "Go", "Rust"]
sorted_a = sorted(a)
print("按照默认排序: ", sorted_a)

sorted_a = sorted(a, key=cmp_to_key(cmp))
print("自定义排序: ", sorted_a)

# 按照默认排序:  ['C++', 'Go', 'Java', 'Python', 'Rust', 'Swift']
# 自定义排序:  ['Go', 'C++', 'Java', 'Rust', 'Swift', 'Python']
```

```python
# 对于list，可以直接调用sort，直接在原list上进行排序
a = [1, 3, 2, 5, 4]
sorted_a = sorted(a)
print("a = ", a)  # [1, 3, 2, 5, 4] 
print("sorted_a = ", sorted_a)  # [1, 2, 3, 4, 5]

sorted_a = a.sort()
print("a = ", a)  # a =  [1, 2, 3, 4, 5]   
print("sorted_a = ", sorted_a)  # None


# 也可以用cmp自定义一个排序方式
# a.sort(key=cmp_to_key(cmp)) 直接输出a即可
```

# 4. 二分查找

```python
from bisect import * 

'''维护一个已排序的列表，支持二分查找，而二分插入
bisect_left(a, x, lo=0, hi=len(a)):
    查找有序列表a中，插入x的第一个位置
    如果a中存在元素x，则返回第一个x的位置

bisect_right(a, x, lo=0, hi=len(a)):
    查找有序列表a中，插入x的最后一个位置
    如果a中存在元素x，则返回最后一个x的位置+1

insort_left(a, x, lo=0, hi=len(a)):
    在第一个位置插入元素x保持有序
insort_right(a, x, lo=0, hi=len(a)):
    在最后一个位置插入元素x保持有序
'''
a = [1, 1, 2, 2, 2, 4, 7]
x = 3
print("x = {}, a中查找的第一个位置为：{}".format(x, bisect_left(a, x)))

x = 2
print("x = {}, a中查找的第一个位置为：{}".format(x, bisect_left(a, x)))

x = 2
print("x = {}, a中查找的最后一个位置为：{}".format(x, bisect_right(a, x)))

x = 100
print("x = {}, a中查找的第一个位置为：{}".format(x, bisect_left(a, x)))

'''print
x = 3, a中查找的第一个位置为：5
x = 2, a中查找的第一个位置为：2  
x = 2, a中查找的最后一个位置为：5
x = 100, a中查找的第一个位置为：7
'''

x = 3
insort_right(a, x)
print("a = ", a)  # a =  [1, 1, 2, 2, 2, 3, 4, 7]
```


