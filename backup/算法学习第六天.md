# 递归
递归：通过自我调用来解决问题的函数

- 通常把一个大型问题层层转化为一个与原问题相似的**规模较小的问题**来求解

递归时要注意：

- 递归出口
  
- 当前问题如何变成子问题
  

**递归求阶乘**：

```python
def f(n):
    # 递归出口
    if n <= 1:
        return 1
    ans = n * f(n - 1)

    return ans

print(f(5))  # 120
```

![](http://cdn.jsdelivr.net/gh/Carolynhomes/images@main/img/study/SuanFa202411171959659.png)

**汉诺塔**：

```python
# n个盘子从A挪到C，借助B
def Move(n, A, B, C):
    # 递归出口
    if n == 0:
        return
    # n-1个盘子从A挪到B
    Move(n - 1, A, C, B)
    # 第n个盘子从A挪到C
    print("{}->{}".format(A, C))
    # n-1个盘子从B挪到C
    Move(n - 1, B, A, C)

n = int(input())
Move(n, 'A', 'B', 'C')
```
# 进制转换
# 1. 任意进制转十进制

```python
int_to_char = "0123456789ABCDEF"
char_to_int = {}
for idx, char in enumerate(int_to_char):
    char_to_int[char] = idx

# k进制数字x转换成十进制：0-9、A-F
def k_to_ten(k, x):
    ans = 0
    for char in x:
        ans = ans * k + char_to_int[char]
    return ans

res = k_to_ten(2, "10001")
print(res)
```

# 2. 十进制转任意进制

除K取余法：十进制数字不断除以K求余数，然后逆序输出

```python
int_to_char = "0123456789ABCDEF"

# 十进制x转为k进制
def ten_to_k(k, x):
    ans = ""
    while x != 0:
        ans += int_to_char[x % k]
        x //= k
    
    return ans[::-1]

print(ten_to_k(16, 31))
```