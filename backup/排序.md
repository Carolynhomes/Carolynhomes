# 1. 冒泡排序

```python
n = int(input())
a = list(map(int, input().split()))

# 循环n-1次
for i in range(1, n):
    # 第i次从a[0]到a[n-i-1]
    for j in range(n-i):
        if a[j] < a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]

print(" ".join(map(str, a)))
```

# 2. 选择排序

```python
n = int(input())
a = list(map(int, input().split()))

# 循环n-1次
for i in range(0, n-1):
    # 第i次从a[i]到a[n-1]找最小元素
    min_value = a[i]
    min_index = i
    # 前 i 个已经是排序成功的
    for j in range(i, n):
        if a[j] < min_value:
            min_value = a[j]
            min_index = j
    a[i], a[min_index] = a[min_index], a[i]

print(" ".join(map(str, a)))
```

# 3. 插入排序

```python
n = int(input())
a = list(map(int, input().split()))

# 对于第i个数字，在区间[0, i-1]中从后往前找对应插入的位置
for i in range(1, n):
    value = a[i]
    # 插入元素的下标
    insert_idx = 0
    for j in range(i-1, -1, -1):
        if a[j] > value:
            # 往后挪
            a[j + 1] = a[j]
        else:
            insert_idx = j + 1
            break

    # 插入第i个数字
    a[insert_idx] = value

print(" ".join(map(str, a)))
```

# 4. 快速排序

```python
# 找一个基准值
# 把列表分成三部分：小于等于x的数字，x，大于x的数字
# 左半部分和右半部分递归使用该策略

#  a[left, right]按照小于等于基准值，基准值、大于基准值排列
def partition(a, left, right):
    # 设置基准值下标：left
    # idx 坐标的左边 都是小于等于基准值的元素
    idx = left + 1

    for i in range(left + 1, right + 1):
        # 如果当前元素小于等于基准值，则放到最小元素那边
        if a[i] <= a[left]:
            a[idx], a[i] = a[i], a[idx]
            idx += 1

    # 小于等于基准值的元素为[left+1, idx-1]
    # 最后将基准值放在中间
    a[left], a[idx-1] = a[idx-1], a[left]

    # 返回基准值的下标
    return idx-1

def quicksort(a, left, right):
    if left < right:
        mid = partition(a, left, right)
        quicksort(a, left, mid - 1)
        quicksort(a, mid + 1, right)

n = int(input())
a = list(map(int, input().split()))

quicksort(a, 0, n - 1)
print(" ".join(map(str, a)))
```

# 5. 归并排序

```python
# 合并排序
def Merge(A, B):
    result = []
    while len(A) != 0 and len(B) != 0:
        if A[0] <= B[0]:
            result.append(A.pop(0))
        else:
            result.append(B.pop(0))

    result.extend(A)
    result.extend(B)
    return result

def MergeSort(A):
    if len(A) < 2:
        return A
    mid = len(A) // 2
    left = MergeSort(A[:mid])
    right = MergeSort(A[mid:])
    return Merge(left, right)

n = int(input())
a = list(map(int, input().split()))
print(" ".join(map(str, MergeSort(a))))
```

# 6. 桶排序

桶排序（Bucket Sort）是一种**分配排序算法**，适合用于对**数值分布较为均匀**的数据进行排序。

其基本思想是`将待排序的数据划分到多个桶中，然后分别对每个桶中的数据进行排序，最后按顺序将桶中的数据合并`。`桶排序通常 在数据分布均匀且范围已知 的情况下效果较好。`

### 桶排序的步骤

1. **划分桶的区间**：根据数据的范围和分布情况，将数据划分到若干个区间（桶）中。通常是均匀划分的。
2. **分配元素**：遍历数据，将每个数据项根据其值放入对应的桶中。
3. **对每个桶内排序**：对每个桶中的数据单独进行排序（通常使用快速排序或插入排序，具体可以根据数据量选择）。
4. **合并结果**：依次遍历每个桶，将桶中的数据按照顺序依次放入最终的数组中，完成排序。

```python
# 导入 itertools 中的 chain，用于将多个桶中的列表合并为一个列表
from itertools import chain

def bucket_sort(a, bucketcount):
    # 找到数组中的最小值和最大值，用于确定桶的范围
    minvalue, maxvalue = min(a), max(a)

    # 计算每个桶的大小
    # (maxvalue - minvalue + 1) 是数据的范围，除以桶的数量得到每个桶的区间大小
    bucketsize = (maxvalue - minvalue + 1) // bucketcount

    # 初始化桶，使用列表推导创建 (bucketcount + 1) 个空列表，用于存放桶中的元素
    res = [[] for i in range(bucketcount + 1)]

    # 将每个元素分配到对应的桶中
    for x in a:
        # 根据元素的值确定其应该分配到哪个桶
        # idx 是桶的索引，通过计算 (x - minvalue) // bucketsize 得到
        idx = (x - minvalue) // bucketsize
        res[idx].append(x)

    # 对每个桶单独进行排序，这里使用 Python 内置的 sort 方法
    # 实际应用中，可以根据需要选择不同的排序算法
    for res_x in res:
        res_x.sort()

    # 使用 chain 将所有桶中的元素按顺序合并为一个列表
    # 最终返回排序后的列表
    return list(chain(*res))

# 读取输入数据
n = int(input())  # 输入元素个数
# 将输入的数字字符串拆分并转换为整数，存储在列表 a 中
a = list(map(int, input().split()))

# 调用 bucket_sort 进行排序
# 使用 min(n, 10000) 作为桶的数量，以确保桶的数量不会过大
a = bucket_sort(a, min(n, 10000))

# 输出排序后的结果，以空格分隔
print(" ".join(map(str, a)))
```